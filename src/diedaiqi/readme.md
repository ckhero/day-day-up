##迭代器使用场景根据类Iterator生成<<br><br>

使用返回迭代器的包或库时（如 PHP5 中的 SPL 迭代器）<br>
无法在一次调用获取所需的所有元素时<br>
要处理数量巨大的元素时（数据库中要处理的结果集内容超过内存）<br>

###生成器  根据类 generators生成<br><br>
需要 PHP 5 >= 5.5.0 或 PHP 7<br>
生成器则提供了一种更简单的方式来实现简单的对象迭代，相比定义类来实现 Iterator 接口的方式，性能开销和复杂度大大降低。<br>

##yield 关键字<br>

需要注意的是 yield 关键字，这是生成器的关键。通过上面的例子可以看出，yield 会将当前产生的值传递给 foreach，换句话说，foreach 每一次迭代过程都会从 yield 处取一个值，直到整个遍历过程不再能执行到 yield 时遍历结束，此时生成器函数简单的退出，而调用生成器的上层代码还可以继续执行，就像一个数组已经被遍历完了。<br>

yield 最简单的调用形式看起来像一个 return 申明，不同的是 yield <b>暂停</b>当前过程的执行并返回值，而 return 是<b>中断</b>当前过程并返回值。暂停当前过程，意味着将处理权转交由上一级继续进行，直到上一级再次调用被暂停的过程，该过程又会从上一次暂停的位置继续执行。这像是什么呢？如果之前已经在鸟哥的文章中粗略看过，应该知道这很像操作系统的进程调度，多个进程在一个 CPU 核心上执行，在系统调度下每一个进程执行一段指令就被暂停，切换到下一个进程，这样外部用户看起来就像是同时在执行多个任务。<br>

<a href="https://www.jianshu.com/p/edef1cb7fee6?open_source=weibo_search">https://www.jianshu.com/p/edef1cb7fee6?open_source=weibo_search</a><br>
###协程 意义<br><br>
协程可以理解为纯用户态的线程，通过协作而不是抢占来进行任务切换。相对于进程或者线程，协程所有的操作都可以在用户态而非操作系统内核态完成，创建和切换的消耗非常低。

简单的说 Coroutine（协程） 就是提供一种方法来中断当前任务的执行，保存当前的局部变量，下次再过来又可以恢复当前局部变量继续执行。

我们可以把大任务拆分成多个小任务轮流执行，如果有某个小任务在等待系统 IO，就跳过它，执行下一个小任务，这样往复调度，实现了 IO 操作和 CPU 计算的并行执行，总体上就提升了任务的执行效率，这也便是协程的意义。

作者：Newt0n
链接：https://www.jianshu.com/p/edef1cb7fee6
來源：简书
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。